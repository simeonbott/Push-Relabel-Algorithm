# Push-Relabel-Algorithm
Python code related to the push relabel algorithm. Attached is a sample dataset with 1000 nodes and 2000 edges and an acknowledgement of the source. This is a base python script that does not use any additional libraries. A faster runtime could be achieved using the pandas library, or a different programming language.

For the original push-relabel algorithm: Goldberg A.V., Tarjan E.R.: A new approach to the maximum-flow problem. J. Assoc. Comput. Mach. 35, 921â€“940 (1988)
DOI: 10.1145/48014.61051

You may wish to visit other sources for a more hands-on explanation of the algorithmic process.

Usage: Push-relabel is one of many techniques for solving local flow problems, that is routing a certain amount of supply around a network starting from the source and ending at the sink. Solving a variety of flow problems, or else proving that no solution exists, on a network can tell connectivity patterns within the network itself. This type of probing is necessary due to the innate scaling complexity of networks. In particular, there is a continuous effort to find effective algorithms for working on flow problems. 

The python implementation in this repository is fairly standard. There are numerous modifications to the push-relabel algorithm that can be made and have been studied. The algorithm employs a deterministic lowest-label queue, and is designed as a double list variable to keep the runtime low, avoiding the O(n^2) normally associated with utilising nxn value tables, such as an adjacency matrix. This implementation does not however, contain a data structure for choosing which neighbour to attempt to push to, so is not fully optimised. (Although this is far less important for thhe runtime than avoiding the adjacency matrix.)

Details about the variables: The source and sink are listed with an entry for each node. This can be imagined as the two nodes floating outside of the network and adjacent to those nodes as indexed in the list. To use only a single source or sink, write the list with only non-zero value. The limit variable declares the label value that a node should be reach before the algorithm stops trying to push flow off of it. It is generally recommended to add an additional counter to break the while loop - 2*Limit*number_nodes*number_edges is a good value for this. (the algorithm should typically end beforehand). The limit value itself is essential to the algorithm as a way to stop the process in the event that the flow problem is extremely difficult or unsolvable. If the limit value is reached, this is not a proof that no solution exists, but push-relabel is resilient and will reach a solution eventually, it's just not always clear exactly what the limit value should be. Although if limit = O(log(n)) where n is the number of nodes, and the algorithm fails, it's extremely likely that there is no solution for the flow problem posed.
